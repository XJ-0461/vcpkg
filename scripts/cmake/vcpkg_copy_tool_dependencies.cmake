# Find the dependency tool (dumpbin, llvm-objdump, or objdump) and set the output variables accordingly.
#
# param DEPENDENCY_TOOL_RESULT - string, required, output variable. full path to the tool executable
# param PARTIAL_DEPENDENCY_TOOL_COMMAND_RESULT - list<string>, required. output variable.
#   some command line arguments that should be passed to the tool. Will be appended with the name of the target file later.
# param REGEX_RESULT - string, required, output variable. regex to match the dependencies in the output of the command
# param REPLACE_RESULT - string, required, output variable. regex to clean the results of the REGEX_RESULT
# param SUCCESS_RESULT - boolean, required, output variable. to quickly indicate success or failure
function(z_vcpkg_find_dependency_tool)

    set(oneValueArgs DEPENDENCY_TOOL_RESULT PARTIAL_DEPENDENCY_TOOL_COMMAND_RESULT
        REGEX_RESULT REPLACE_RESULT SUCCESS_RESULT)
    cmake_parse_arguments(z_vcpkg_find_dependency_tool "" "${oneValueArgs}" "" ${ARGN})

    if (NOT z_vcpkg_find_dependency_tool_DEPENDENCY_TOOL_RESULT)
        message(FATAL_ERROR "z_vcpkg_find_dependency_tool: Missing required argument 'DEPENDENCY_TOOL_RESULT'")
    endif()
    if (NOT z_vcpkg_find_dependency_tool_PARTIAL_DEPENDENCY_TOOL_COMMAND_RESULT)
        message(FATAL_ERROR "z_vcpkg_find_dependency_tool: Missing required argument 'PARTIAL_DEPENDENCY_TOOL_COMMAND_RESULT'")
    endif()
    if (NOT z_vcpkg_find_dependency_tool_REGEX_RESULT)
        message(FATAL_ERROR "z_vcpkg_find_dependency_tool: Missing required argument 'REGEX_RESULT'")
    endif()
    if (NOT z_vcpkg_find_dependency_tool_REPLACE_RESULT)
        message(FATAL_ERROR "z_vcpkg_find_dependency_tool: Missing required argument 'REPLACE_RESULT'")
    endif()
    if (NOT z_vcpkg_find_dependency_tool_SUCCESS_RESULT)
        message(FATAL_ERROR "z_vcpkg_find_dependency_tool: Missing required argument 'SUCCESS_RESULT'")
    endif()

    find_program(dumpbin_executable_ dumpbin)
    find_program(llvm_objdump_executable_ llvm-objdump)
    find_program(objdump_executable_ objdump)

    if (dumpbin_executable_)
        set(${z_vcpkg_find_dependency_tool_DEPENDENCY_TOOL_RESULT} "${_dumpbin_executable_}" PARENT_SCOPE)
        set(${z_vcpkg_find_dependency_tool_PARTIAL_DEPENDENCY_TOOL_COMMAND_RESULT} "/DEPENDENTS" PARENT_SCOPE)
        set(${z_vcpkg_find_dependency_tool_REGEX_RESULT} "^    [^ ].*\.dll" PARENT_SCOPE) # todo: update this regex
        set(${z_vcpkg_find_dependency_tool_REPLACE_RESULT} "^    " PARENT_SCOPE)  # todo: update this regex
        set(${z_vcpkg_find_dependency_tool_SUCCESS_RESULT} TRUE PARENT_SCOPE)
    elseif (llvm_objdump_executable_)
        set(${z_vcpkg_find_dependency_tool_DEPENDENCY_TOOL_RESULT} "${_llvm_objdump_executable_}" PARENT_SCOPE)
        set(${z_vcpkg_find_dependency_tool_PARTIAL_DEPENDENCY_TOOL_COMMAND_RESULT} "-p" PARENT_SCOPE)
        set(${z_vcpkg_find_dependency_tool_REGEX_RESULT} "DLL Name: [^\r\n]*\.dll" PARENT_SCOPE)
        set(${z_vcpkg_find_dependency_tool_REPLACE_RESULT} "DLL Name: " PARENT_SCOPE)
        set(${z_vcpkg_find_dependency_tool_SUCCESS_RESULT} TRUE PARENT_SCOPE)
    elseif (objdump_executable_)
        set(${z_vcpkg_find_dependency_tool_DEPENDENCY_TOOL_RESULT} "${_objdump_executable_}" PARENT_SCOPE)
        set(${z_vcpkg_find_dependency_tool_PARTIAL_DEPENDENCY_TOOL_COMMAND_RESULT} "-p" PARENT_SCOPE)
        set(${z_vcpkg_find_dependency_tool_REGEX_RESULT} "DLL Name: [^\r\n]*\.dll" PARENT_SCOPE)
        set(${z_vcpkg_find_dependency_tool_REPLACE_RESULT} "DLL Name: " PARENT_SCOPE)
        set(${z_vcpkg_find_dependency_tool_SUCCESS_RESULT} TRUE PARENT_SCOPE)
    else()
        message(WARNING "z_vcpkg_find_dependency_tool: Could not find dumpbin, llvm-objdump, or objdump")
        set(${z_vcpkg_find_dependency_tool_SUCCESS_RESULT} FALSE PARENT_SCOPE)
    endif()

endfunction()

# Run the command, capture the output, and parse it for dependencies. Return the dependencies as a list of filenames.
# The command should be composed of output from z_vcpkg_find_dependency_tool and the target file to be resolved.
#
# param DEPENDENCY_COMMAND - list<string>, required. forwarded to execute_process
# param MATCH_REGEX - string, required. regex to match the dependencies in the output
# param REPLACE_REGEX - string, required. regex to clean the results of the MATCH_REGEX
# param DEPENDENCIES_RESULT - list<string>, required, output variable. dependencies found by the command
# param SUCCESS_RESULT - boolean, required, output variable. to quickly indicate success or failure to the caller
# param ERROR_MESSAGES_RESULT - list<string>, optional, output variable. error messages generated by the command (if any)
function(z_vcpkg_get_object_dependencies)

    set(one_value_args_ DEPENDENCY_COMMAND MATCH_REGEX REPLACE_REGEX DEPENDENCIES_RESULT SUCCESS_RESULT ERROR_MESSAGES_RESULT)
    cmake_parse_arguments(z_vcpkg_get_object_dependencies "" "${one_value_args_}" "" ${ARGN})

    if (NOT z_vcpkg_get_object_dependencies_DEPENDENCY_COMMAND)
        message(FATAL_ERROR "z_vcpkg_get_object_dependencies: Missing required argument 'DEPENDENCY_COMMAND'")
    endif()
    if (NOT z_vcpkg_get_object_dependencies_MATCH_REGEX)
        message(FATAL_ERROR "z_vcpkg_get_object_dependencies: Missing required argument 'MATCH_REGEX'")
    endif()
    if (NOT z_vcpkg_get_object_dependencies_REPLACE_REGEX)
        message(FATAL_ERROR "z_vcpkg_get_object_dependencies: Missing required argument 'REPLACE_REGEX'")
    endif()
    if (NOT z_vcpkg_get_object_dependencies_DEPENDENCIES_RESULT)
        message(FATAL_ERROR "z_vcpkg_get_object_dependencies: Missing required argument 'DEPENDENCIES_RESULT'")
    endif()
    if (NOT z_vcpkg_get_object_dependencies_SUCCESS_RESULT)
        message(FATAL_ERROR "z_vcpkg_get_object_dependencies: Missing required argument 'SUCCESS_RESULT'")
    endif()

    set(command_ ${${z_vcpkg_get_object_dependencies_DEPENDENCY_COMMAND}})
    execute_process(
        COMMAND ${command_}
        OUTPUT_VARIABLE command_output_
        ERROR_VARIABLE command_error_
        RESULT_VARIABLE command_result_
    )

    if (NOT command_result_ EQUAL 0)
        list(JOIN ${z_vcpkg_get_object_dependencies_DEPENDENCY_COMMAND} " " command_string_)
        set(${z_vcpkg_get_object_dependencies_SUCCESS_RESULT} FALSE PARENT_SCOPE)
        if (z_vcpkg_get_object_dependencies_ERROR_MESSAGES_RESULT)
            set(${z_vcpkg_get_object_dependencies_ERROR_MESSAGES_RESULT}
                "Dependency tool command '${command_string_}' - failed with details:"
                "Result: ${command_result_}"
                "Error: ${command_error_}"
                PARENT_SCOPE
            )
        endif()
        return()
    endif()

    string(REGEX MATCHALL "${z_vcpkg_get_object_dependencies_MATCH_REGEX}" matches_ "${command_output_}")
    set(cleaned_dependencies_ "")
    foreach(match_ IN LISTS matches_)
        string(REGEX REPLACE "${z_vcpkg_get_object_dependencies_REPLACE_REGEX}" "" cleaned_ "${match_}")
        LIST(APPEND cleaned_dependencies_ "${cleaned_}")
    endforeach()

    set(${z_vcpkg_get_object_dependencies_DEPENDENCIES_RESULT} "${cleaned_dependencies_}" PARENT_SCOPE)
    set(${z_vcpkg_get_object_dependencies_SUCCESS_RESULT} TRUE PARENT_SCOPE)

endfunction()

# Given a list of targets, try to resolve all of their transitive dependencies and deploy them to the target directory.
# Success measures are a bit dubious for this kind of operation because of loading mechanisms that do not require that
# each and every dependency need be in the same directory as your target. So, some dependencies are not required to be
# 'resolved' in this context for the target to still work properly. It is a case-by-case basis. Sometimes, a target will
# require special handling to ensure it works properly; that logic should be added to the Special Handling region.
# param TARGET_OBJECT_PATHS - list<string>, required. list of target object paths to resolve.
#   e.g. "/path/to/myproject.exe;/some/path/somedll.dll;/my/dependency/libthing.dll"
#
# param ADDITIONAL_SEARCH_PATHS - list<string>, optional. additional search paths to use when resolving dependencies
# param SUCCESS_RESULT - boolean, required, output variable. to quickly indicate success or failure to the caller
# param RESOLVED_DEPENDENCIES_RESULT - list<string>, optional, output variable. list of resolved dependencies
# param UNRESOLVED_DEPENDENCIES_RESULT - list<string>, optional, output variable. list of unresolved dependencies
function(vcpkg_resolve_deploy_object_dependencies)

    set(one_value_args_ SUCCESS_RESULT RESOLVED_DEPENDENCIES_RESULT UNRESOLVED_DEPENDENCIES_RESULT)
    set(multi_value_args_ TARGET_OBJECT_PATHS ADDITIONAL_SEARCH_PATHS)
    cmake_parse_arguments(vcpkg_resolve_deploy_object_dependencies "" "${one_value_args_}" "${multi_value_args_}" ${ARGN})

    if (NOT vcpkg_resolve_deploy_object_dependencies_SUCCESS_RESULT)
        message(FATAL_ERROR "vcpkg_resolve_deploy_object_dependencies: Missing required argument 'SUCCESS_RESULT'")
    endif()

    if (NOT vcpkg_resolve_deploy_object_dependencies_TARGET_OBJECT_PATHS)
        message(FATAL_ERROR "vcpkg_resolve_deploy_object_dependencies: Missing required argument 'TARGET_OBJECT_PATHS'")
        set(${vcpkg_resolve_deploy_object_dependencies_SUCCESS_RESULT} FALSE PARENT_SCOPE)
    endif()

    z_vcpkg_find_dependency_tool(
        DEPENDENCY_TOOL_RESULT dependency_tool_
        PARTIAL_DEPENDENCY_TOOL_COMMAND_RESULT partial_dependency_tool_command_
        REGEX_RESULT dependency_tool_regex_
        REPLACE_RESULT dependency_tool_replace_
        SUCCESS_RESULT dependency_tool_success_
    )

    if (NOT dependency_tool_success_)
        message(FATAL_ERROR "resolve_dependencies: Could not find dependency tool")
        set(${vcpkg_resolve_deploy_object_dependencies_SUCCESS_RESULT} FALSE PARENT_SCOPE)
    endif()

    set(search_paths_ ${vcpkg_resolve_deploy_object_dependencies_ADDITIONAL_SEARCH_PATHS})
    set(to_be_resolved_stack_ "")

    foreach (target_ IN LISTS vcpkg_resolve_deploy_object_dependencies_TARGET_OBJECT_PATHS)
        get_filename_component(target_directory_ "${target_}" DIRECTORY)
        list(PREPEND search_paths_ "${target_directory_}")
        get_filename_component(target_filename_ "${target_}" NAME)
        list(APPEND to_be_resolved_stack_ "${target_filename_}")
    endforeach()
    list(REMOVE_DUPLICATES search_paths_)
    list(REMOVE_DUPLICATES to_be_resolved_stack_)

    set(all_dependencies_ "")
    set(resolved_files_ "")
    set(unresolved_files_ "")
    set(processed_files_ "")
    set(processed_var_names_ "")

    # Gather all the targets to be resolved, keep track of each dependency's dependencies..
    while (to_be_resolved_stack_) # For each target

        list(POP_FRONT to_be_resolved_stack_ current_target_)

        get_filename_component(current_target_filename_ ${current_target_} NAME)
        vcpkg_make_cmake_identifier(INPUT "${current_target_filename_}" OUTPUT_VARIABLE current_var_name_)

        # applocal.ps1 asserts that current_target_dir_ is some /bin directory.
        get_filename_component(current_target_dir_ ${current_target_} DIRECTORY)
        cmake_path(GET current_target_dir_ PARENT_PATH current_target_install_root_dir_)

        # If the the directory name is debug or debug/ (trailing slash)
        set(current_target_install_root_dir_is_debug_ FALSE)
        if (current_target_install_root_dir_ MATCHES "[/\\]debug[/\\]?$")
            set(current_target_install_root_dir_is_debug_ TRUE)
        endif()

        if ("${current_var_name_}" IN_LIST processed_var_names_)
            message(STATUS "vcpkg_resolve_deploy_object_dependencies: ${current_target_filename_} already processed, skipping")
            continue()
        endif()

        message(STATUS "vcpkg_resolve_deploy_object_dependencies: Gathering dependencies for ${current_target_filename_}")

        # Try to find the file, if possible
        unset(find_file_result_) # If not unset, find_file will short circuit fail (in our case)
        find_file(
            find_file_result_
            NAMES "${current_target_}"
            PATHS ${search_paths_}
            PATH_SUFFIXES bin
            NO_DEFAULT_PATH
            NO_CACHE
        )

        list(APPEND processed_files_ "${current_target_}")
        list(APPEND processed_var_names_ "${current_var_name_}")

        if (find_file_result_ STREQUAL "find_file_result_-NOTFOUND")
            message(STATUS "vcpkg_resolve_deploy_object_dependencies: Could not find ${current_target_} in the available search paths")
            # If we can't find it, we can't resolve it, move on
            list(APPEND unresolved_files_ "${current_target_}")
            continue()
        endif()

        # Otherwise, mark as resolved - keep digging
        set(${current_varname_}_resolved_location_ "${find_file_result_}")
        list(APPEND resolved_files_ "${find_file_result_}")

        # region Special Handling
        # Some projects deploy tools that require tender care in order to function. Check if we are dealing with
        # one of those, if so, handle it.
        # Note to implementers: If your project requires special handling, add it in this region.

        detect_dependency_qt_module(
            TARGET_OBJECT_PATH "${find_file_result_}"
            IS_DETECTED_RESULT is_detected_
        )
        if (is_detected_)
            message(STATUS "vcpkg_resolve_deploy_object_dependencies: Found Qt module in ${find_file_result_}. Handling with care.")
            cmake_path(APPEND current_target_install_root_dir_ "plugins" OUTPUT_VARIABLE qt_plugins_dir_)
            deploy_dependencies_qt_module(
                TARGET_OBJECT_PATH "${find_file_result_}"
                QT_PLUGINS_DIR "${qt_plugins_dir_}"
                DEPLOYED_FILES_RESULT deployed_files_list_
                DEPENDENCIES_TO_RESOLVE_RESULT to_resolve_list_
            )
            list(APPEND to_be_resolved_stack_ "${to_resolve_list_}")
        endif()

        detect_dependency_OpenNI2(
            TARGET_OBJECT_PATH "${find_file_result_}"
            IS_DETECTED_RESULT is_detected_
        )
        if (is_detected_)
            message(STATUS "vcpkg_resolve_deploy_object_dependencies: Found OpenNI2 module in ${find_file_result_}. Handling with care.")
            deploy_dependencies_OpenNI2(
                TARGET_OBJECT_PATH "${find_file_result_}"
                OPEN_NI2_INSTALLED_DIR "${current_target_install_root_dir_}"
                DEPLOYED_FILES_RESULT deployed_files_list_
                DEPENDENCIES_TO_RESOLVE_RESULT to_resolve_list_
            )
            list(APPEND to_be_resolved_stack_ "${to_resolve_list_}")
        endif()

        detect_dependency_magnum(
            TARGET_OBJECT_PATH "${find_file_result_}"
            IS_DETECTED_RESULT is_detected_
        )
        if (is_detected)
            message(STATUS "vcpkg_resolve_deploy_object_dependencies: Found Magnum module in ${find_file_result_}. Handling with care.")
            if (current_target_install_root_dir_is_debug_)
                cmake_path(APPEND current_target_install_root_dir_ "bin" "magnum-d" OUTPUT_VARIABLE magnum_plugins_dir_)
            else()
                cmake_path(APPEND current_target_install_root_dir_ "bin" "magnum" OUTPUT_VARIABLE magnum_plugins_dir_)
            endif()
            deploy_dependencies_magnum(
                TARGET_OBJECT_PATH "${find_file_result_}"
                MAGNUM_PLUGINS_DIR "${magnum_plugins_dir_}"
                DEPLOYED_FILES_RESULT deployed_files_list_
                DEPENDENCIES_TO_RESOLVE_RESULT to_resolve_list_
            )
            list(APPEND to_be_resolved_stack_ "${to_resolve_list_}")
        endif()

        detect_dependency_azure_kinect_sensor_sdk(
            TARGET_OBJECT_PATH "${find_file_result_}"
            IS_DETECTED_RESULT is_detected_
        )
        if (is_detected_)
            message(STATUS "vcpkg_resolve_deploy_object_dependencies: Found Azure Kinect Sensor SDK in ${find_file_result_}. Handling with care.")
            deploy_dependencies_azure_kinect_sensor_sdk(
                TARGET_OBJECT_PATH "${find_file_result_}"
                KINECT_INSTALLED_DIR "${current_target_install_root_dir_}"
                DEPLOYED_FILES_RESULT deployed_files_list_
                DEPENDENCIES_TO_RESOLVE_RESULT to_resolve_list_
            )
            list(APPEND to_be_resolved_stack_ "${to_resolve_list_}")
        endif()

        # endregion Special Handling

        set(get_dependencies_command_ "${dependency_tool_}" "${partial_dependency_tool_command_}" "${find_file_result_}")
        z_vcpkg_get_object_dependencies(
            DEPENDENCY_COMMAND get_dependencies_command_
            MATCH_REGEX "${dependency_tool_regex_}"
            REPLACE_REGEX "${dependency_tool_replace_}"
            DEPENDENCIES_RESULT extracted_dependencies_
            SUCCESS_RESULT get_dependencies_success_
            ERROR_MESSAGES_RESULT error_messages_
        )

        # Getting an error here is not necessarily fatal, we may just be dealing with a target that is not objdump-able
        # Perhaps some port author snuck it into the list of dependencies to be further resolved
        # Dont throw the baby out with the bathwater, log it and move on
        if (NOT get_dependencies_success_)
            list(JOIN error_messages_ "\n" error_message_)
            message(WARNING "${error_message_}")
        endif()

        # Prepare next iteration of the while loop
        list(APPEND ${current_var_name_}_all_dependencies_ "${extracted_dependencies_}")
        list(REMOVE_DUPLICATES ${current_var_name_}_all_dependencies_)
        set(${current_var_name_}_all_dependencies_ "${${current_var_name_}_all_dependencies_}" PARENT_SCOPE)
        list(APPEND all_dependencies_ "${extracted_dependencies_}")
        list(REMOVE_DUPLICATES all_dependencies_)
        foreach (extracted_dependency_ IN LISTS extracted_dependencies_)
            if (NOT "${extracted_dependency_}" IN_LIST processed_files_)
                list(APPEND to_be_resolved_stack_ "${extracted_dependency_}")
            endif()
        endforeach()
        list(REMOVE_DUPLICATES to_be_resolved_stack_)

        # Pretty print the dependencies for the current DLL
        message(STATUS "vcpkg_resolve_deploy_object_dependencies: Identified dependencies for: ${current_target_}")
        foreach (extracted_dependency_ IN LISTS ${current_varname_}_all_dependencies_)
            message(STATUS " - ${extracted_dependency_}")
        endforeach()

    endwhile()

    # Reporting section, for debugging and info purposes
    # Code looks ugly to make the output look pretty
    foreach (found_location_ IN LISTS resolved_files_)

        get_filename_component(target_filename_ ${found_location_} NAME)
        vcpkg_make_cmake_identifier(INPUT "${target_filename_}" OUTPUT_VARIABLE target_varname_)
        set(target_dependencies_ "${${target_varname_}_all_dependencies_}")
        unset(target_resolved_dependencies_)
        unset(target_unresolved_dependencies_)
        set(resolved_dependency_max_string_length_ 0)
        set(unresolved_dependency_max_string_length_ 0)

        foreach (dependency_ IN LISTS target_dependencies_)
            string(LENGTH "${dependency_}" dependency_length_)
            vcpkg_make_cmake_identifier(INPUT "${dependency_}" OUTPUT_VARIABLE dependency_varname_)
            if (${dependency_varname_}_resolved_location_)
                vcpkg_max(VALUES "${dependency_length_}" "${resolved_dependency_max_string_length_}"
                        OUTPUT_VARIABLE resolved_dependency_max_string_length_
                )
                list(APPEND target_resolved_dependencies_ "${dependency_}")
            else()
                vcpkg_max(VALUES "${dependency_length_}" "${unresolved_dependency_max_string_length_}"
                        OUTPUT_VARIABLE unresolved_dependency_max_string_length_
                )
                list(APPEND target_unresolved_dependencies_ "${dependency_}")
            endif()
        endforeach()
        set(${target_varname_}_resolved_dependencies_ "${target_resolved_dependencies_}")
        set(${target_varname_}_unresolved_dependencies_ "${target_unresolved_dependencies_}")

        message(STATUS "vcpkg_resolve_deploy_object_dependencies: ${target_filename_} - Dependency Resolution Summary")
        message(STATUS "  Resolved Dependencies:")
        foreach (resolved_ IN LISTS target_resolved_dependencies_)
            string(LENGTH "${resolved_}" dependency_length_)
            math(EXPR string_padding_length_ "${resolved_dependency_max_string_length_} - ${dependency_length_}")
            vcpkg_make_cmake_identifier(INPUT "${resolved_}" OUTPUT_VARIABLE dependency_varname_)
            set(temp_str_ "    ${resolved_}")
            foreach (it RANGE ${string_padding_length_})
                string(APPEND temp_str_ " ")
            endforeach()
            string(APPEND temp_str_ "-> ${${dependency_varname_}_resolved_location_}")
            message(STATUS "${temp_str_}")
        endforeach()

        message(STATUS "  Unresolved Dependencies:")
        foreach (unresolved_ IN LISTS target_unresolved_dependencies_)
            string(LENGTH "${unresolved_}" dependency_length_)
            math(EXPR string_padding_length_ "${unresolved_dependency_max_string_length_} - ${dependency_length_}")
            vcpkg_make_cmake_identifier(INPUT "${unresolved_}" OUTPUT_VARIABLE dependency_varname_)
            set(temp_str_ "    ${unresolved_}")
            foreach (it RANGE ${string_padding_length_})
                string(APPEND temp_str_ " ")
            endforeach()
            string(APPEND temp_str_ "-> NOT FOUND")
            message(STATUS "${temp_str_}")
        endforeach()

    endforeach()

    message(STATUS "vcpkg_resolve_deploy_object_dependencies: Copying resolved dependencies to their respective target directories")
    # For each dependency found, deploy it to the same directory as the target DLL
    foreach(resolved_target_ IN LISTS resolved_files_)

        get_filename_component(target_filename_ ${resolved_target_} NAME)
        get_filename_component(target_dir_ ${resolved_target_} DIRECTORY)

        message(STATUS "vcpkg_resolve_deploy_object_dependencies: Copying dependencies for ${target_filename_}")

        vcpkg_make_cmake_identifier(INPUT "${target_filename_}" OUTPUT_VARIABLE target_varname_)
        set(target_resolved_dependencies_ "${${target_varname_}_resolved_dependencies_}")

        foreach (dependency_ IN LISTS target_resolved_dependencies_)
            vcpkg_make_cmake_identifier(INPUT "${dependency_}" OUTPUT_VARIABLE dependency_varname_)
            set(dependency_resolved_location_ "${${dependency_varname_}_resolved_location_}")
            get_filename_component(found_dir_ "${dependency_resolved_location_}" DIRECTORY)
            get_filename_component(dependency_filename_ "${dependency_resolved_location_}" NAME)
            cmake_path(APPEND target_dir_ "${dependency_filename_}" OUTPUT_VARIABLE new_location_)
            unset(find_file_result_)
            find_file(find_file_result_ NO_CACHE
                NAMES "${dependency_filename_}"
                PATHS "${target_dir_}"
            )
            if (NOT find_file_result_ STREQUAL "find_file_result_-NOTFOUND")
                message(STATUS "vcpkg_resolve_deploy_object_dependencies: ${target_filename_} dependency - ${dependency_} already exists at ${new_location_}. Will not copy.")
                continue()
            endif()

            vcpkg_copy_from_directory(
                FROM_DIRECTORY "${found_dir_}"
                TO_DIRECTORY "${target_dir_}"
                FILE_PATTERNS "${dependency_filename_}"
                COPIED_FILES_RESULT deployed_files_list_
            )

        endforeach()
    endforeach()

    if (vcpkg_resolve_deploy_object_dependencies_RESOLVED_DEPENDENCIES_RESULT)
        set(${vcpkg_resolve_deploy_object_dependencies_RESOLVED_DEPENDENCIES_RESULT} "${resolved_files_}" PARENT_SCOPE)
    endif()
    if (vcpkg_resolve_deploy_object_dependencies_UNRESOLVED_DEPENDENCIES_RESULT)
        set(${vcpkg_resolve_deploy_object_dependencies_UNRESOLVED_DEPENDENCIES_RESULT} "${unresolved_files_}" PARENT_SCOPE)
    endif()

endfunction()

function(z_vcpkg_copy_tool_dependencies_search tool_dir path_to_search)
    if(DEFINED Z_VCPKG_COPY_TOOL_DEPENDENCIES_COUNT)
        set(count ${Z_VCPKG_COPY_TOOL_DEPENDENCIES_COUNT})
    else()
        set(count 0)
    endif()
    file(GLOB tools "${tool_dir}/*.exe" "${tool_dir}/*.dll" "${tool_dir}/*.pyd")
    list(LENGTH tools tools_count_)
    set(Z_VCPKG_COPY_TOOL_DEPENDENCIES_COUNT ${tools_count_} CACHE INTERNAL "")
    vcpkg_resolve_deploy_object_dependencies(
        TARGET_OBJECT_PATHS ${tools}
        ADDITIONAL_SEARCH_PATHS "${path_to_search}"
        DEPENDENCY_LIST_RESULT deployed_dependencies_
        SUCCESS_RESULT is_successful_
    )
endfunction()

function(vcpkg_copy_tool_dependencies tool_dir)
    if(ARGC GREATER 1)
        message(WARNING "${CMAKE_CURRENT_FUNCTION} was passed extra arguments: ${ARGN}")
    endif()

    if(VCPKG_TARGET_IS_WINDOWS)
        find_program(Z_VCPKG_POWERSHELL_CORE pwsh)
        if (NOT Z_VCPKG_POWERSHELL_CORE)
            message(FATAL_ERROR "Could not find PowerShell Core; please open an issue to report this.")
        endif()
        cmake_path(RELATIVE_PATH tool_dir
            BASE_DIRECTORY "${CURRENT_PACKAGES_DIR}"
            OUTPUT_VARIABLE relative_tool_dir
        )
        if(relative_tool_dir MATCHES "^debug/|/debug/")
            set(additional_search_paths_ "${CURRENT_PACKAGES_DIR}/debug/bin" "${CURRENT_INSTALLED_DIR}/debug/bin")
            z_vcpkg_copy_tool_dependencies_search("${tool_dir}" "${additional_search_paths_}")
        else()
            set(additional_search_paths_ "${CURRENT_PACKAGES_DIR}/bin" "${CURRENT_INSTALLED_DIR}/bin")
            z_vcpkg_copy_tool_dependencies_search("${tool_dir}" "${additional_search_paths_}")
        endif()
    endif()
endfunction()

# region Special Handlers

# Given a target, check if it is a Magnum module. Return TRUE or FALSE.
#
# param TARGET_OBJECT_PATH - string, required. path to the target object
# param IS_DETECTED_RESULT - boolean, required, output variable. TRUE if the target is a Magnum module, FALSE otherwise
function(detect_dependency_magnum)

    set(one_value_args_ TARGET_OBJECT_PATH IS_DETECTED_RESULT)
    cmake_parse_arguments(detect_dependency_magnum "" "${one_value_args_}" "" ${ARGN})

    if (NOT detect_dependency_magnum_TARGET_OBJECT_PATH)
        message(FATAL_ERROR "detect_dependency_magnum: Missing required argument 'TARGET_OBJECT_PATH'")
    endif()
    if (NOT detect_dependency_magnum_IS_DETECTED_RESULT)
        message(FATAL_ERROR "detect_dependency_magnum: Missing required argument 'IS_DETECTED_RESULT'")
    endif()

    get_filename_component(target_name_ "${detect_dependency_magnum_TARGET_OBJECT_PATH}" NAME)

    if (target_name_ MATCHES "MagnumAudio(-d)?\\.dll"
        OR target_name_ MATCHES "MagnumText(-d)?\\.dll"
        OR target_name_ MATCHES "MagnumTrade(-d)?\\.dll"
        OR target_name_ MATCHES "MagnumShaderTools(-d)?\\.dll"
    )
        set(${detect_dependency_magnum_IS_DETECTED_RESULT} TRUE PARENT_SCOPE)
    else()
        set(${detect_dependency_magnum_IS_DETECTED_RESULT} FALSE PARENT_SCOPE)
    endif()

endfunction()

# Magnum's plugin deployment strategy is that each Magnum module has a hardcoded
# set of plugin directories. Each of these directories is deployed in
# full if that Module is referenced.
#
# param TARGET_OBJECT_PATH - string, required. path to the target object
# param MAGNUM_PLUGINS_DIR - string, required. path to the Magnum plugins directory
# param DEPLOYED_FILES_RESULT - list<string>, required, output variable. list of deployed files
# param DEPENDENCIES_TO_RESOLVE_RESULT - list<string>, required, output variable. list of dependencies that need further resolution
function(deploy_dependencies_magnum)

    set(one_value_args_ TARGET_OBJECT_PATH MAGNUM_PLUGINS_DIR DEPLOYED_FILES_RESULT DEPENDENCIES_TO_RESOLVE_RESULT)
    cmake_parse_arguments(deploy_plugins_magnum "" "${one_value_args_}" "" ${ARGN})

    if (NOT deploy_plugins_magnum_TARGET_OBJECT_PATH)
        message(FATAL_ERROR "deploy_plugins_magnum: Missing required argument 'TARGET_OBJECT_PATH'")
    endif()
    if (NOT deploy_plugins_magnum_MAGNUM_PLUGINS_DIR)
        message(FATAL_ERROR "deploy_plugins_magnum: Missing required argument 'MAGNUM_PLUGINS_DIR'")
    endif()
    if (NOT deploy_plugins_magnum_DEPLOYED_FILES_RESULT)
        message(FATAL_ERROR "deploy_plugins_magnum: Missing required argument 'DEPLOYED_FILES_RESULT'")
    endif()
    if (NOT deploy_plugins_magnum_DEPENDENCIES_TO_RESOLVE_RESULT)
        message(FATAL_ERROR "deploy_plugins_magnum: Missing required argument 'DEPENDENCIES_TO_RESOLVE_RESULT'")
    endif()

    get_filename_component(target_name_ "${deploy_plugins_magnum_TARGET_OBJECT_PATH}" NAME) # targetBinaryName
    get_filename_component(target_dir_ "${deploy_plugins_magnum_TARGET_OBJECT_PATH}" DIRECTORY) # targetBinaryDir

    cmake_path(GET deploy_plugins_magnum_MAGNUM_PLUGINS_DIR PARENT_PATH plugins_base_dir_) #baseDir
    cmake_path(APPEND plugins_base_dir_ "bin" OUTPUT_VARIABLE plugins_bin_dir_) #binDir
    get_filename_component(plugins_base_dir_name_ "${plugins_base_dir_}" NAME) #baseDirName

    message(STATUS "Deploying magnum plugins")
    set(all_copied_files_list_ "")

    # We detect Magnum modules in use via the DLLs that contain their plugin interfaces
    if (target_name_ MATCHES "MagnumAudio(-d)?\\.dll")
        cmake_path(APPEND deploy_plugins_magnum_MAGNUM_PLUGINS_DIR "audioimporters" OUTPUT_VARIABLE from_directory_)
        cmake_path(APPEND target_dir_ "${plugins_base_dir_name_}" "audioimporters" OUTPUT_VARIABLE to_directory_)
        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${from_directory_}"
            TO_DIRECTORY "${to_directory_}"
            EXTENSIONS DLL CONF PDB
            COPIED_FILES_RESULT deployed_files_list_
        )
        list(APPEND all_copied_files_list_ "${deployed_files_list_}")
    endif()

    if (target_name_ MATCHES "MagnumText(-d)?\\.dll")
        cmake_path(APPEND deploy_plugins_magnum_MAGNUM_PLUGINS_DIR "fonts" OUTPUT_VARIABLE from_directory_)
        cmake_path(APPEND target_dir_ "${plugins_base_dir_name_}" "fonts" OUTPUT_VARIABLE to_directory_)
        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${from_directory_}"
            TO_DIRECTORY "${to_directory_}"
            EXTENSIONS DLL CONF PDB
            COPIED_FILES_RESULT deployed_files_list_
        )
        list(APPEND all_copied_files_list_ "${deployed_files_list_}")

        cmake_path(APPEND deploy_plugins_magnum_MAGNUM_PLUGINS_DIR "fontconverters" OUTPUT_VARIABLE from_directory_)
        cmake_path(APPEND target_dir_ "${plugins_base_dir_name_}" "fontconverters" OUTPUT_VARIABLE to_directory_)
        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${from_directory_}"
            TO_DIRECTORY "${to_directory_}"
            EXTENSIONS DLL CONF PDB
            COPIED_FILES_RESULT deployed_files_list_
        )
        list(APPEND all_copied_files_list_ "${deployed_files_list_}")
    endif()

    if (target_name_ MATCHES "MagnumTrade(-d)?\\.dll")
        cmake_path(APPEND deploy_plugins_magnum_MAGNUM_PLUGINS_DIR "importers" OUTPUT_VARIABLE from_directory_)
        cmake_path(APPEND target_dir_ "${plugins_base_dir_name_}" "importers" OUTPUT_VARIABLE to_directory_)
        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${from_directory_}"
            TO_DIRECTORY "${to_directory_}"
            EXTENSIONS DLL CONF PDB
            COPIED_FILES_RESULT deployed_files_list_
        )
        list(APPEND all_copied_files_list_ "${deployed_files_list_}")

        cmake_path(APPEND deploy_plugins_magnum_MAGNUM_PLUGINS_DIR "imageconverters" OUTPUT_VARIABLE from_directory_)
        cmake_path(APPEND target_dir_ "${plugins_base_dir_name_}" "imageconverters" OUTPUT_VARIABLE to_directory_)
        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${from_directory_}"
            TO_DIRECTORY "${to_directory_}"
            EXTENSIONS DLL CONF PDB
            COPIED_FILES_RESULT deployed_files_list_
        )
        list(APPEND all_copied_files_list_ "${deployed_files_list_}")

        cmake_path(APPEND deploy_plugins_magnum_MAGNUM_PLUGINS_DIR "sceneconverters" OUTPUT_VARIABLE from_directory_)
        cmake_path(APPEND target_dir_ "${plugins_base_dir_name_}" "sceneconverters" OUTPUT_VARIABLE to_directory_)
        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${from_directory_}"
            TO_DIRECTORY "${to_directory_}"
            EXTENSIONS DLL CONF PDB
            COPIED_FILES_RESULT deployed_files_list_
        )
        list(APPEND all_copied_files_list_ "${deployed_files_list_}")
    endif()

    if (target_name_ MATCHES "MagnumShaderTools(-d)?\\.dll")
        cmake_path(APPEND deploy_plugins_magnum_MAGNUM_PLUGINS_DIR "shaderconverters" OUTPUT_VARIABLE from_directory_)
        cmake_path(APPEND target_dir_ "${plugins_base_dir_name_}" "shaderconverters" OUTPUT_VARIABLE to_directory_)
        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${from_directory_}"
            TO_DIRECTORY "${to_directory_}"
            EXTENSIONS DLL CONF PDB
            COPIED_FILES_RESULT deployed_files_list_
        )
        list(APPEND all_copied_files_list_ "${deployed_files_list_}")
    endif()

    set(${deploy_plugins_magnum_DEPLOYED_FILES_RESULT} "${all_copied_files_list_}" PARENT_SCOPE)
    set(${deploy_plugins_magnum_DEPENDENCIES_TO_RESOLVE_RESULT} "${all_copied_files_list_}" PARENT_SCOPE)

endfunction()

# Given a target, check if it is an Azure Kinect Sensor SDK module. Return TRUE or FALSE.
#
# param TARGET_OBJECT_PATH - string, required. path to the target object
# param IS_DETECTED_RESULT - boolean, required, output variable. TRUE if the target is an Azure Kinect Sensor SDK module, FALSE otherwise
function(detect_dependency_azure_kinect_sensor_sdk)

    set(one_value_args_ TARGET_OBJECT_PATH IS_DETECTED_RESULT)
    cmake_parse_arguments(detect_azure_kinect_sensor_sdk "" "${one_value_args_}" "" ${ARGN})

    if (NOT detect_azure_kinect_sensor_sdk_TARGET_OBJECT_PATH)
        message(FATAL_ERROR "detect_azure_kinect_sensor_sdk: Missing required argument 'TARGET_OBJECT_PATH'")
    endif()
    if (NOT detect_azure_kinect_sensor_sdk_IS_DETECTED_RESULT)
        message(FATAL_ERROR "detect_azure_kinect_sensor_sdk: Missing required argument 'IS_DETECTED_RESULT'")
    endif()

    get_filename_component(target_name_ "${detect_azure_kinect_sensor_sdk_TARGET_OBJECT_PATH}" NAME)

    if (target_name_ STREQUAL "k4a.dll")
        set(${detect_azure_kinect_sensor_sdk_IS_DETECTED_RESULT} TRUE PARENT_SCOPE)
    else()
        set(${detect_azure_kinect_sensor_sdk_IS_DETECTED_RESULT} FALSE PARENT_SCOPE)
    endif()

endfunction()

# Special handling for Azure Kinect Sensor SDK
#
# param TARGET_OBJECT_PATH - string, required. path to the target object
# param KINECT_INSTALLED_DIR - string, required. path to the Azure Kinect Sensor SDK installation directory
# param DEPLOYED_FILES_RESULT - list<string>, required, output variable. list of deployed files
# param DEPENDENCIES_TO_RESOLVE_RESULT - list<string>, required, output variable. list of dependencies that need further resolution
function(deploy_dependencies_azure_kinect_sensor_sdk)

    set(one_value_args_ TARGET_OBJECT_PATH KINECT_INSTALLED_DIR DEPLOYED_FILES_RESULT DEPENDENCIES_TO_RESOLVE_RESULT)
    cmake_parse_arguments(deploy_dependencies_azure_kinect_sensor_sdk "" "${one_value_args_}" "" ${ARGN})

    if (NOT deploy_dependencies_azure_kinect_sensor_sdk_TARGET_OBJECT_PATH)
        message(FATAL_ERROR "deploy_dependencies_azure_kinect_sensor_sdk: Missing required argument 'TARGET_OBJECT_PATH'")
    endif()
    if (NOT deploy_dependencies_azure_kinect_sensor_sdk_KINECT_INSTALLED_DIR)
        message(FATAL_ERROR "deploy_dependencies_azure_kinect_sensor_sdk: Missing required argument 'KINECT_INSTALLED_DIR'")
    endif()
    if (NOT deploy_dependencies_azure_kinect_sensor_sdk_DEPLOYED_FILES_RESULT)
        message(FATAL_ERROR "deploy_dependencies_azure_kinect_sensor_sdk: Missing required argument 'DEPLOYED_FILES_RESULT'")
    endif()
    if (NOT deploy_dependencies_azure_kinect_sensor_sdk_DEPENDENCIES_TO_RESOLVE_RESULT)
        message(FATAL_ERROR "deploy_dependencies_azure_kinect_sensor_sdk: Missing required argument 'DEPENDENCIES_TO_RESOLVE_RESULT'")
    endif()

    message(STATUS "deploy_dependencies_azure_kinect_sensor_sdk: Deploying Azure Kinect Sensor SDK Initialization")
    get_filename_component(target_dir_ "${deploy_dependencies_azure_kinect_sensor_sdk_TARGET_OBJECT_PATH}" DIRECTORY)

    cmake_path(APPEND deploy_dependencies_azure_kinect_sensor_sdk_KINECT_INSTALLED_DIR "tools" "azure-kinect-sensor-sdk"
            OUTPUT_VARIABLE kinect_dependency_location_
    )

    set(deployed_files_list_ "")
    if (EXISTS "${kinect_dependency_location_}")
        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${kinect_dependency_location_}"
            TO_DIRECTORY "${target_dir_}"
            FILE_PATTERNS "depthengine_2_0.dll"
            COPIED_FILES_RESULT deployed_files_list_
        )
    else()
        message(FATAL_ERROR "deploy_dependencies_azure_kinect_sensor_sdk: Could not find Azure Kinect Sensor SDK dependency at ${kinect_dependency_location_}")
    endif()

    set(${deploy_dependencies_azure_kinect_sensor_sdk_DEPLOYED_FILES_RESULT} "${deployed_files_list_}" PARENT_SCOPE)
    set(${deploy_dependencies_azure_kinect_sensor_sdk_DEPENDENCIES_TO_RESOLVE_RESULT} "" PARENT_SCOPE)

endfunction()

# Given a target, check if it is a Qt module that requires special handling. Return TRUE or FALSE.
#
# param TARGET_OBJECT_PATH - string, required. path to the target object
# param IS_DETECTED_RESULT - boolean, required, output variable. TRUE if the target is a Qt module, FALSE otherwise
function(detect_dependency_qt_module)

    set(one_value_args_ TARGET_OBJECT_PATH IS_DETECTED_RESULT)
    cmake_parse_arguments(detect_dependency_qt_module "" "${one_value_args_}" "" ${ARGN})

    if (NOT detect_dependency_qt_module_TARGET_OBJECT_PATH)
        message(FATAL_ERROR "detect_dependency_qt_module: Missing required argument 'TARGET_OBJECT_PATH'")
    endif()
    if (NOT detect_dependency_qt_module_IS_DETECTED_RESULT)
        message(FATAL_ERROR "detect_dependency_qt_module: Missing required argument 'IS_DETECTED_RESULT'")
    endif()

    get_filename_component(target_name_ "${detect_dependency_qt_module_TARGET_OBJECT_PATH}" NAME)

    if (target_name_ MATCHES "Qt5.*\\.dll")
        set(${detect_dependency_qt_module_IS_DETECTED_RESULT} TRUE PARENT_SCOPE)
    else()
        set(${detect_dependency_qt_module_IS_DETECTED_RESULT} FALSE PARENT_SCOPE)
    endif()

endfunction()

# Special handling for Qt modules
#
# param TARGET_OBJECT_PATH - string, required. path to the target object
# param QT_PLUGINS_DIR - string, required. path to the Qt plugins directory
# param DEPLOYED_FILES_RESULT - list<string>, required, output variable. list of deployed files
# param DEPENDENCIES_TO_RESOLVE_RESULT - list<string>, required, output variable. list of dependencies that need further resolution
function(deploy_dependencies_qt_module)

    set(one_value_args_ TARGET_OBJECT_PATH QT_PLUGINS_DIR DEPLOYED_FILES_RESULT DEPENDENCIES_TO_RESOLVE_RESULT)
    cmake_parse_arguments(deploy_dependencies_qt_module "" "${one_value_args_}" "" ${ARGN})

    if (NOT deploy_dependencies_qt_module_TARGET_OBJECT_PATH)
        message(FATAL_ERROR "deploy_dependencies_qt_module: Missing required argument 'TARGET_OBJECT_PATH'")
    endif()
    if (NOT deploy_dependencies_qt_module_QT_PLUGINS_DIR)
        message(FATAL_ERROR "deploy_dependencies_qt_module: Missing required argument 'QT_PLUGINS_DIR'")
    endif()
    if (NOT deploy_dependencies_qt_module_DEPLOYED_FILES_RESULT)
        message(FATAL_ERROR "deploy_dependencies_qt_module: Missing required argument 'DEPLOYED_FILES_RESULT'")
    endif()
    if (NOT deploy_dependencies_qt_module_DEPENDENCIES_TO_RESOLVE_RESULT)
        message(FATAL_ERROR "deploy_dependencies_qt_module: Missing required argument 'DEPENDENCIES_TO_RESOLVE_RESULT'")
    endif()

    set(all_copied_files_ "")
    set(still_to_resolve_files_ "")

    cmake_path(GET deploy_dependencies_qt_module_QT_PLUGINS_DIR PARENT_PATH qt_plugins_base_dir_)
    cmake_path(APPEND qt_plugins_base_dir_ "bin" OUTPUT_VARIABLE qt_plugins_bin_dir_)
    get_filename_component(target_name_ "${deploy_dependencies_qt_module_TARGET_OBJECT_PATH}" NAME)
    get_filename_component(target_dir_ "${deploy_dependencies_qt_module_TARGET_OBJECT_PATH}" DIRECTORY)
    cmake_path(APPEND target_dir_ "plugins" OUTPUT_VARIABLE target_plugins_dir_)

    message(STATUS "deploy_dependencies_qt_module: Deploying Qt5 Module: ${target_name_}")

    # Ensure that the qt.conf file exists, if not, create it
    if (target_name_ MATCHES "Qt5Cored?.dll")
        cmake_path(APPEND target_dir_ "qt.conf" OUTPUT_VARIABLE qt_conf_path_)
        if (NOT EXISTS "${qt_conf_path_}")
            message(STATUS "deploy_dependencies_qt_module: qt.conf file does not exist at ${qt_conf_path_}. Creating it.")
            file(WRITE "${qt_conf_path_}" "[Paths]")
        endif()
    endif()

    if (target_name_ MATCHES "Qt5Guid?.dll")

        message(STATUS "deploy_dependencies_qt_module: Deploying platforms")
        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/platforms"
            TO_DIRECTORY "${target_plugins_dir_}/platforms"
            COPIED_FILES_RESULT deployed_files_
            FILE_PATTERNS "qwindows*.dll"
        )
        list(APPEND all_copied_files_ "${deployed_files_}")

        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/accessible"
            TO_DIRECTORY "${target_plugins_dir_}/accessible"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")

        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/imageformats"
            TO_DIRECTORY "${target_plugins_dir_}/imageformats"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")

        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/iconengines"
            TO_DIRECTORY "${target_plugins_dir_}/iconengines"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")

        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/platforminputcontexts"
            TO_DIRECTORY "${target_plugins_dir_}/platforminputcontexts"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")

        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/styles"
            TO_DIRECTORY "${target_plugins_dir_}/styles"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")

    endif() # Qt5Guid?.dll

    if (target_name_ MATCHES "Qt5Networkd?.dll")

        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/bearer"
            TO_DIRECTORY "${target_plugins_dir_}/bearer"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")

        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${qt_plugins_bin_dir_}"
            TO_DIRECTORY "${target_dir_}"
            FILE_PATTERNS "libcrypto-*-x64.dll" "libssl-*-x64.dll" "libcrypto-*.dll" "libssl-*.dll"
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")

    endif() # Qt5Networkd?.dll

    if (target_name_ MATCHES "Qt5Sqld?.dll")
        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/sqldrivers"
            TO_DIRECTORY "${target_plugins_dir_}/sqldrivers"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")
    endif() # Qt5Sqld?.dll

    if (target_name_ MATCHES "Qt5Multimediad?.dll")

        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/audio"
            TO_DIRECTORY "${target_plugins_dir_}/audio"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")

        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/mediaservice"
            TO_DIRECTORY "${target_plugins_dir_}/mediaservice"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")

        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/playlistformats"
            TO_DIRECTORY "${target_plugins_dir_}/playlistformats"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")

    endif() # Qt5Multimediad?.dll

    if (target_name_ MATCHES "Qt5PrintSupportd?.dll")

        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/printsupport"
            TO_DIRECTORY "${target_plugins_dir_}/printsupport"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")

    endif() # Qt5PrintSupportd?.dll

    if (target_name_ MATCHES "Qt5Qmld?.dll")

        # Ensure that /qml directory exists and its populated with bin/qml files
        if (NOT EXISTS "${target_dir_}/qml")
            message(STATUS "deploy_dependencies_qt_module: Creating /qml directory at ${target_dir_}/qml")
            file(MAKE_DIRECTORY "${target_dir_}/qml")
            # Try to find the files to copy from
            cmake_path(APPEND qt_plugins_base_dir_ "qml" OUTPUT_VARIABLE qml_source_dir_option_0_)
            cmake_path(APPEND qt_plugins_base_dir_ ".." "qml" OUTPUT_VARIABLE qml_source_dir_option_1_)
            if (EXISTS "${qml_source_dir_option_0_}")
                message(STATUS "deploy_dependencies_qt_module: Found qml source directory at ${qml_source_dir_option_0_}. Copying directory to ${target_dir_}/qml")
                file(COPY "${qml_source_dir_option_0_}" DESTINATION "${target_dir_}/qml")
            elseif (EXISTS "${qml_source_dir_option_1_}")
                message(STATUS "deploy_dependencies_qt_module: Found qml source directory at ${qml_source_dir_option_1_}. Copying directory to ${target_dir_}/qml")
                file(COPY "${qml_source_dir_option_1_}" DESTINATION "${target_dir_}/qml")
            else()
                message(FATAL_ERROR "deploy_dependencies_qt_module: Could not find qml source directory at ${qml_source_dir_}")
            endif()
        endif()

        set(dlls_to_copy_
            "Qt5Quick.dll"
            "Qt5Quickd.dll"
            "Qt5QmlModels.dll"
            "Qt5QmlModelsd.dll"
            "Qt5QuickControls2.dll"
            "Qt5QuickControls2d.dll"
            "Qt5QuickShapes.dll"
            "Qt5QuickShapesd.dll"
            "Qt5QuickTemplates2.dll"
            "Qt5QuickTemplates2d.dll"
            "Qt5QmlWorkerScript.dll"
            "Qt5QmlWorkerScriptd.dll"
            "Qt5QuickParticles.dll"
            "Qt5QuickParticlesd.dll"
            "Qt5QuickWidgets.dll"
            "Qt5QuickWidgetsd.dll"
        )
        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${qt_plugins_bin_dir_}"
            TO_DIRECTORY "${target_dir_}"
            FILE_PATTERNS "${dlls_to_copy_}"
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")

        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/scenegraph"
            TO_DIRECTORY "${target_plugins_dir_}/scenegraph"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")

        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/qmltooling"
            TO_DIRECTORY "${target_plugins_dir_}/qmltooling"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")

    endif() # Qt5Qmld?.dll

    if (target_name_ MATCHES "Qt5Quickd?.dll")

        set(dlls_to_copy_
            "Qt5QuickControls2.dll"
            "Qt5QuickControls2d.dll"
            "Qt5QuickShapes.dll"
            "Qt5QuickShapesd.dll"
            "Qt5QuickTemplates2.dll"
            "Qt5QuickTemplates2d.dll"
            "Qt5QmlWorkerScript.dll"
            "Qt5QmlWorkerScriptd.dll"
            "Qt5QuickParticles.dll"
            "Qt5QuickParticlesd.dll"
            "Qt5QuickWidgets.dll"
            "Qt5QuickWidgetsd.dll"
        )
        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${qt_plugins_bin_dir_}"
            TO_DIRECTORY "${target_dir_}"
            FILE_PATTERNS "${dlls_to_copy_}"
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")

        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/scenegraph"
            TO_DIRECTORY "${target_plugins_dir_}/scenegraph"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")

        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/qmltooling"
            TO_DIRECTORY "${target_plugins_dir_}/qmltooling"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")

    endif() # Qt5Quickd?.dll

    if (target_name_ MATCHES "Qt5Declarative*.dll")
        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/qml1tooling"
            TO_DIRECTORY "${target_plugins_dir_}/qml1tooling"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")
    endif() # Qt5Declarative*.dll

    if (target_name_ MATCHES "Qt5Positioning*.dll")
        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/position"
            TO_DIRECTORY "${target_plugins_dir_}/position"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")
    endif() # Qt5Positioning*.dll

    if (target_name_ MATCHES "Qt5Location*.dll")
        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/geoservices"
            TO_DIRECTORY "${target_plugins_dir_}/geoservices"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")
    endif() # Qt5Location*.dll

    if (target_name_ MATCHES "Qt5Sensors*.dll")

        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/sensors"
            TO_DIRECTORY "${target_plugins_dir_}/sensors"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")

        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/sensorgestures"
            TO_DIRECTORY "${target_plugins_dir_}/sensorgestures"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")

    endif() # Qt5Sensors*.dll

    if (target_name_ MATCHES "Qt5WebEngineCore*.dll")
        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/qtwebengine"
            TO_DIRECTORY "${target_plugins_dir_}/qtwebengine"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")
    endif() # Qt5WebEngineCore*.dll

    if (target_name_ MATCHES "Qt53DRenderer*.dll")
        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/sceneparsers"
            TO_DIRECTORY "${target_plugins_dir_}/sceneparsers"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")
    endif() # Qt53DRenderer*.dll

    if (target_name_ MATCHES "Qt5TextToSpeech*.dll")
        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/texttospeech"
            TO_DIRECTORY "${target_plugins_dir_}/texttospeech"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")
    endif() # Qt5TextToSpeech*.dll

    if (target_name_ MATCHES "Qt5SerialBus*.dll")
        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${deploy_dependencies_qt_module_QT_PLUGINS_DIR}/canbus"
            TO_DIRECTORY "${target_plugins_dir_}/canbus"
            EXTENSIONS DLL
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
        list(APPEND still_to_resolve_files_ "${deployed_files_}")
    endif() # Qt5SerialBus*.dll

    list(REMOVE_DUPLICATES all_copied_files_)
    set(${deploy_dependencies_qt_module_DEPLOYED_FILES_RESULT} "${all_copied_files_}" PARENT_SCOPE)
    set(${deploy_dependencies_qt_module_DEPENDENCIES_TO_RESOLVE_RESULT} "${still_to_resolve_files_}" PARENT_SCOPE)

endfunction()

# Given a target, check if it is an OpenNI2 module. Return TRUE or FALSE.
#
# param TARGET_OBJECT_PATH - string, required. path to the target object
# param IS_DETECTED_RESULT - boolean, required, output variable. TRUE if the target is an OpenNI2 module, FALSE otherwise
function(detect_dependency_OpenNI2)

    set(one_value_args_ TARGET_OBJECT_PATH IS_DETECTED_RESULT)
    cmake_parse_arguments(detect_dependency_OpenNI2 "" "${one_value_args_}" "" ${ARGN})

    if (NOT detect_dependency_OpenNI2_TARGET_OBJECT_PATH)
        message(FATAL_ERROR "detect_dependency_OpenNI2: Missing required argument 'TARGET_OBJECT_PATH'")
    endif()
    if (NOT detect_dependency_OpenNI2_IS_DETECTED_RESULT)
        message(FATAL_ERROR "detect_dependency_OpenNI2: Missing required argument 'IS_DETECTED_RESULT'")
    endif()

    get_filename_component(target_name_ "${detect_dependency_OpenNI2_TARGET_OBJECT_PATH}" NAME)

    if (target_name_ MATCHES "OpenNI2.dll")
        set(${detect_dependency_OpenNI2_IS_DETECTED_RESULT} TRUE PARENT_SCOPE)
    else()
        set(${detect_dependency_OpenNI2_IS_DETECTED_RESULT} FALSE PARENT_SCOPE)
    endif()

endfunction()

# Special handling for OpenNI2 modules
#
# param TARGET_OBJECT_PATH - string, required. path to the target object
# param OPEN_NI2_INSTALLED_DIR - string, required. path to the OpenNI2 installation directory
# param DEPLOYED_FILES_RESULT - list<string>, required, output variable. list of deployed files
# param DEPENDENCIES_TO_RESOLVE_RESULT - list<string>, required, output variable. list of dependencies that need further resolution
function(deploy_dependencies_OpenNI2)

    set(one_value_args_ TARGET_OBJECT_PATH OPEN_NI2_INSTALLED_DIR DEPLOYED_FILES_RESULT DEPENDENCIES_TO_RESOLVE_RESULT)
    cmake_parse_arguments(deploy_dependencies_OpenNI2 "" "${one_value_args_}" "" ${ARGN})

    if (NOT deploy_dependencies_OpenNI2_TARGET_OBJECT_PATH)
        message(FATAL_ERROR "deploy_dependencies_OpenNI2: Missing required argument 'TARGET_OBJECT_PATH'")
    endif()
    if (NOT deploy_dependencies_OpenNI2_OPEN_NI2_INSTALLED_DIR)
        message(FATAL_ERROR "deploy_dependencies_OpenNI2: Missing required argument 'OPEN_NI2_INSTALLED_DIR'")
    endif()
    if (NOT deploy_dependencies_OpenNI2_DEPLOYED_FILES_RESULT)
        message(FATAL_ERROR "deploy_dependencies_OpenNI2: Missing required argument 'DEPLOYED_FILES_RESULT'")
    endif()

    set(all_copied_files_ "")

    cmake_path(APPEND deploy_dependencies_OpenNI2_OPEN_NI2_INSTALLED_DIR "bin" "OpenNI2" OUTPUT_VARIABLE openni2_bin_base_dir_)
    cmake_path(APPEND openni2_bin_base_dir_ "OpenNI.ini" OUTPUT_VARIABLE ini_location_)

    get_filename_component(target_dir_ "${deploy_dependencies_OpenNI2_TARGET_OBJECT_PATH}" DIRECTORY)

    if (EXISTS "${ini_location_}")
        message(STATUS "deploy_dependencies_OpenNI2: Deploying OpenNI2 Initialization")
        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${openni2_bin_base_dir_}"
            TO_DIRECTORY "${target_dir_}"
            FILE_PATTERNS "OpenNI.ini"
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
    endif()

    cmake_path(APPEND openni2_bin_base_dir_ "Drivers" OUTPUT_VARIABLE openni2_drivers_dir_)
    cmake_path(APPEND target_dir_ "OpenNI2" "Drivers" OUTPUT_VARIABLE target_drivers_dir_)

    if (EXISTS openni2_drivers_dir_)
        message(STATUS "deploy_dependencies_OpenNI2: Deploying OpenNI2 Drivers")
        vcpkg_copy_from_directory(
            FROM_DIRECTORY "${openni2_drivers_dir_}"
            TO_DIRECTORY "${target_drivers_dir_}"
            EXTENSIONS DLL INI
            COPIED_FILES_RESULT deployed_files_
        )
        list(APPEND all_copied_files_ "${deployed_files_}")
    endif()

    list(REMOVE_DUPLICATES all_copied_files_)
    set(${deploy_dependencies_OpenNI2_DEPLOYED_FILES_RESULT} "${all_copied_files_}" PARENT_SCOPE)
    if (deploy_dependencies_OpenNI2_DEPENDENCIES_TO_RESOLVE_RESULT) # optional since always returns an empty list
        set(${deploy_dependencies_OpenNI2_DEPENDENCIES_TO_RESOLVE_RESULT} "" PARENT_SCOPE)
    endif()

endfunction()

# endregion Special Handlers